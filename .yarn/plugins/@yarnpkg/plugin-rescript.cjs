/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-rescript",
factory: function (require) {
var plugin;(()=>{"use strict";var e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{default:()=>p});const r=require("clipanion"),o=require("@yarnpkg/core"),s=require("@yarnpkg/cli"),a=require("@yarnpkg/fslib"),n=require("@yarnpkg/plugin-pnp");var i=function(e,t,r,o){var s,a=arguments.length,n=a<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)n=Reflect.decorate(e,t,r,o);else for(var i=e.length-1;i>=0;i--)(s=e[i])&&(n=(a<3?s(n):a>3?s(t,r,n):s(t,r))||n);return a>3&&n&&Object.defineProperty(t,r,n),n};class c extends s.BaseCommand{constructor(){super(...arguments),this.realFs=new a.NodeFS}async execute(){let e=0;const t=await o.Configuration.find(this.context.cwd,this.context.plugins),{project:r,workspace:i}=await o.Project.find(t,this.context.cwd),c=await o.Cache.find(t);if(!i)throw new s.WorkspaceRequiredError(r.cwd,this.context.cwd);await r.restoreInstallState();const p=a.ppath.join(i.cwd,"bsconfig.json");if(!await this.realFs.existsPromise(p))return console.log("TODO: res init first"),1;const l=await this.realFs.readFilePromise(p,"utf8").then(JSON.parse),d=l["bs-dependencies"]||[],h=l["bs-dev-dependencies"]||[],u=(l["ppx-flags"]||[]).map(e=>Array.isArray(e)?e[0]:e).map(e=>{var t;return null===(t=e.match(/^[^\/]+|@[^\/]+\/[^\/]+/))||void 0===t?void 0:t[0]}).filter(Boolean),f=l.gentypeconfig,g=await this.getRescriptPackages(["rescript",f&&"gentype",...d,...h,...u].filter(Boolean),{workspace:i,project:r,cache:c,configuration:t});if(0!==(e=(await o.StreamReport.start({configuration:t,stdout:this.context.stdout,json:this.json},async e=>{let t=!1;for(const e of g){const{version:s}=e,a=r.topLevelWorkspace.manifest.ensureDependencyMeta(o.structUtils.makeDescriptor(e,s));a.unplugged||(a.unplugged=!0,t=!0)}t&&(await r.topLevelWorkspace.persistManifest(),e.reportSeparator(),await r.linkEverything({cache:c,report:e}))})).exitCode()))return e;const w=a.ppath.join(r.cwd,a.Filename.nodeModules);for(const e of g){const r=n.pnpUtils.getUnpluggedPath(e,{configuration:t}),s=o.structUtils.stringifyIdent(e),i=a.ppath.join(r,a.Filename.nodeModules,s),c=a.ppath.join(w,s);await this.realFs.mkdirpPromise(a.ppath.dirname(c)),await this.linkPath(this.realFs,i,c)}return e}async getRescriptPackages(e,{workspace:t,project:r,configuration:s,cache:n}){const i=new Set,c=[],p=s.makeFetcher(),l=async e=>{if(i.has(e.locatorHash))return;i.add(e.locatorHash),r.tryWorkspaceByLocator(e)||c.push(e);const t=new o.ThrowReport,s=await p.fetch(e,{project:r,fetcher:p,cache:n,report:t,checksums:r.storedChecksums});try{const n=(await s.packageFs.readFilePromise(a.ppath.join(s.prefixPath,"bsconfig.json"),"utf8").then(JSON.parse)||{})["bs-dependencies"]||[];for(const t of n){const s=o.structUtils.parseIdent(t),a=e.dependencies.get(s.identHash),n=r.storedResolutions.get(a.descriptorHash);if(!n)throw new Error("Assertion failed: The resolution should have been registered");const i=r.storedPackages.get(n);if(!i)throw new Error("Assertion failed: The package should have been registered");await l(i)}}finally{s.releaseFs(),await t.finalize()}};for(const s of e){const e=o.structUtils.parseIdent(s),a=t.dependencies.get(e.identHash),n=r.storedResolutions.get(a.descriptorHash);if(!n)throw new Error("Assertion failed: The resolution should have been registered");const i=r.storedPackages.get(n);if(!i)throw new Error("Assertion failed: The package should have been registered");await l(i)}return c}async linkPath(e,t,r){try{await e.symlinkPromise(t,r)}catch(o){if("EEXIST"!==(null==o?void 0:o.code))throw o;await e.unlinkPromise(r),await this.linkPath(e,t,r)}}}c.usage=r.Command.Usage({description:"Link rescript dependencies"}),i([r.Command.Boolean("Format the output as an NDJSON stream")],c.prototype,"json",void 0),i([r.Command.Path("res","link")],c.prototype,"execute",null);const p={hooks:{},commands:[c]};plugin=t})();
return plugin;
}
};