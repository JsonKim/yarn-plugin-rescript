/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-rescript",
factory: function (require) {
var plugin=(()=>{var O=Object.create,w=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var F=Object.getOwnPropertyNames;var z=Object.getPrototypeOf,J=Object.prototype.hasOwnProperty;var Y=s=>w(s,"__esModule",{value:!0});var l=s=>{if(typeof require!="undefined")return require(s);throw new Error('Dynamic require of "'+s+'" is not supported')};var $=(s,n)=>{for(var a in n)w(s,a,{get:n[a],enumerable:!0})},X=(s,n,a)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of F(n))!J.call(s,i)&&i!=="default"&&w(s,i,{get:()=>n[i],enumerable:!(a=W(n,i))||a.enumerable});return s},g=s=>X(Y(w(s!=null?O(z(s)):{},"default",s&&s.__esModule&&"default"in s?{get:()=>s.default,enumerable:!0}:{value:s,enumerable:!0})),s);var K={};$(K,{default:()=>G});var _=g(l("child_process"));var E=g(l("clipanion")),e=g(l("@yarnpkg/core")),c=g(l("@yarnpkg/fslib")),S=g(l("@yarnpkg/cli")),D=g(l("@yarnpkg/plugin-essentials")),y=g(l("@yarnpkg/plugin-pnp")),P=class extends S.BaseCommand{async execute(){if(!D.default.commands)throw new Error("Yarn commands are not found. Please upgrade to Yarn 2.");let n=0,a=await e.Configuration.find(this.context.cwd,this.context.plugins),{project:i,workspace:U}=await e.Project.find(a,this.context.cwd),j=await e.Cache.find(a),u=new c.NodeFS;async function C(t,o){try{await u.symlinkPromise(t,o)}catch(r){(r==null?void 0:r.code)==="EEXIST"&&(await u.unlinkPromise(o),await C(t,o))}}let H=c.ppath.join(U.cwd,"bsconfig.json");if(!await u.existsPromise(H))return console.log("TODO: res init first"),0;let I=JSON.parse(await u.readFilePromise(H,"utf8")),A=I["bs-dependencies"]||[],T=I["bs-dev-dependencies"]||[];await i.resolveEverything({cache:j,lockfileOnly:!0,report:new e.ThrowReport});let f=i.storedPackages.get(i.topLevelWorkspace.anchoredLocator.locatorHash),x=new Map,m=new Set;for(let t of A){let o=e.structUtils.parseIdent(t),r=f.dependencies.get(o.identHash);r?x.set(t,{ident:o,descriptor:r}):m.add(t)}let v=new Map,h=new Set;for(let t of T){let o=e.structUtils.parseIdent(t),r=f.dependencies.get(o.identHash);r?v.set(t,{ident:o,descriptor:r}):h.add(t)}{let t=E.Cli.from(D.default.commands);if(m.size>0){if(n=await t.run(["add",[...m].join(" ")],this.context),n!==0)return n;for(let o of m){let r=e.structUtils.parseIdent(o),p=f.dependencies.get(r.identHash);p&&x.set(o,{ident:r,descriptor:p})}}if(h.size>0){if(n=await t.run(["add","--dev",[...h].join(" ")],this.context),n!==0)return n;for(let o of h){let r=e.structUtils.parseIdent(o),p=f.dependencies.get(r.identHash);p&&v.set(o,{ident:r,descriptor:p})}}}let M=new Map([...x,...v]);if(n=(await e.StreamReport.start({configuration:a,stdout:this.context.stdout,json:this.json},async t=>{var o;for(let[,{descriptor:r}]of M){let p=i.storedResolutions.get(r.descriptorHash),d=i.storedPackages.get(p),b=y.pnpUtils.getUnpluggedPath(d,{configuration:a}),k=(o=d.version)!=null?o:"unknown",N=i.topLevelWorkspace.manifest.ensureDependencyMeta(e.structUtils.makeDescriptor(d,k));N.unplugged=!0,t.reportInfo(e.MessageName.UNNAMED,`Will unpack ${e.structUtils.prettyLocator(a,d)} to ${e.formatUtils.pretty(a,y.pnpUtils.getUnpluggedPath(d,{configuration:a}),e.formatUtils.Type.PATH)}`),t.reportJson({locator:e.structUtils.stringifyLocator(d),version:k})}await i.topLevelWorkspace.persistManifest(),t.reportSeparator(),await i.install({cache:j,report:t})})).exitCode(),n!==0)return n;let R=c.ppath.join(i.cwd,c.Filename.nodeModules);for(let[t,{ident:o,descriptor:r}]of M){let p=i.storedResolutions.get(r.descriptorHash),d=i.storedPackages.get(p),b=y.pnpUtils.getUnpluggedPath(d,{configuration:a}),k=c.ppath.join(b,c.Filename.nodeModules,t),N=c.ppath.join(R,t);if(o.scope){let B=c.ppath.join(R,"@"+o.scope);await u.mkdirPromise(B,{recursive:!0})}await C(k,N)}return n}};P.paths=[["res","setup"]];var L=P;var q={hooks:{},commands:[L]},G=q;return K;})();
return plugin;
}
};
