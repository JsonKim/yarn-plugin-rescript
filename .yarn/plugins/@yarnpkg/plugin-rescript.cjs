/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-rescript",
factory: function (require) {
var plugin=(()=>{var L=Object.create,h=Object.defineProperty;var U=Object.getOwnPropertyDescriptor;var Y=Object.getOwnPropertyNames;var J=Object.getPrototypeOf,W=Object.prototype.hasOwnProperty;var X=e=>h(e,"__esModule",{value:!0});var d=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var _=(e,t)=>{for(var c in t)h(e,c,{get:t[c],enumerable:!0})},q=(e,t,c)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of Y(t))!W.call(e,r)&&r!=="default"&&h(e,r,{get:()=>t[r],enumerable:!(c=U(t,r))||c.enumerable});return e},l=e=>q(X(h(e!=null?L(J(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var Q={};_(Q,{default:()=>K});var b=l(d("child_process"));var x=l(d("clipanion")),i=l(d("@yarnpkg/core")),a=l(d("@yarnpkg/fslib")),C=l(d("@yarnpkg/cli")),j=l(d("@yarnpkg/plugin-essentials")),k=l(d("@yarnpkg/plugin-pnp")),w=class extends C.BaseCommand{async execute(){if(!j.default.commands)throw new Error("Yarn commands are not found. Please upgrade to Yarn 2.");let t=0,c=await i.Configuration.find(this.context.cwd,this.context.plugins),{project:r,workspace:R}=await i.Project.find(c,this.context.cwd),f=new a.NodeFS;async function D(s,o){try{await f.symlinkPromise(s,o)}catch(n){(n==null?void 0:n.code)==="EEXIST"&&(await f.unlinkPromise(o),await D(s,o))}}let I=a.ppath.join(R.cwd,"bsconfig.json");if(!await f.existsPromise(I))return console.log("TODO: res init first"),0;let N=JSON.parse(await f.readFilePromise(I,"utf8")),E=N["bs-dependencies"]||[],M=N["bs-dev-dependencies"]||[];await r.resolveEverything({lockfileOnly:!0,report:new i.ThrowReport});let g=r.storedPackages.get(r.topLevelWorkspace.anchoredLocator.locatorHash),u=new Map,y=new Set;for(let s of E){let o=i.structUtils.parseIdent(s),n=g.dependencies.get(o.identHash);n?u.set(s,{ident:o,descriptor:n}):y.add(s)}let m=new Map,P=new Set;for(let s of M){let o=i.structUtils.parseIdent(s),n=g.dependencies.get(o.identHash);n?m.set(s,{ident:o,descriptor:n}):P.add(s)}{let s=x.Cli.from(j.default.commands);if(t=await s.run(["add",[...y].join(" ")],this.context),t!==0)return t;for(let o of y){let n=i.structUtils.parseIdent(o),p=g.dependencies.get(n.identHash);p&&u.set(o,{ident:n,descriptor:p})}if(t=await s.run(["add","--dev",[...P].join(" ")],this.context),t!==0)return t;for(let o of P){let n=i.structUtils.parseIdent(o),p=g.dependencies.get(n.identHash);p&&m.set(o,{ident:n,descriptor:p})}}if(t=await x.Cli.from(k.default.commands).run(["unplug",[...u.keys(),...m.keys()].join(" ")],this.context),t!==0)return t;let v=a.ppath.join(r.cwd,a.Filename.nodeModules),S=new Map([...u,...m]);for(let[s,{ident:o,descriptor:n}]of S){let p=r.storedResolutions.get(n.descriptorHash),B=r.storedPackages.get(p),O=k.pnpUtils.getUnpluggedPath(B,{configuration:r.configuration}),T=a.ppath.join(O,a.Filename.nodeModules,s),A=a.ppath.join(v,"@"+o.scope),F=a.ppath.join(v,s);await f.mkdirPromise(A,{recursive:!0}),await D(T,F)}return t}};w.paths=[["res","setup"]];var H=w;var z=()=>{let e=(0,b.spawn)("yarn",["res","setup"],{encoding:"utf8",shell:!0});e.stdout.on("data",console.log),e.stderr.on("data",console.error),e.on("close",t=>{t!==0&&process.exit(t),console.log("Setup ReScript successfully!")})},G={hooks:{afterAllInstalled:z},commands:[H]},K=G;return Q;})();
return plugin;
}
};
